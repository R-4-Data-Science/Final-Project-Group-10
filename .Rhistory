step <- step + 1
}
list(
path_forest = path_forest,
aic_by_model = aic_by_model,
meta = list(
response = response,
predictors = predictors,
delta = delta,
eps = eps,
L = L,
K = K
)
)
}
set.seed(1)
n <- 120; p <- 8
X <- matrix(rnorm(n*p), n, p)
beta <- c(2, -1.5, 0, 0, 1, rep(0, p-5))
y <- X %*% beta + rnorm(n, sd = 1)
colnames(X) <- paste0("x", 1:p)
df <- as.data.frame(cbind(y, X))
# Fit a few single-step candidates to illustrate AIC comparisons:
aic_empty <- AIC(lm(y ~ 1, data = df))
cand <- lapply(1:p, function(j) lm(as.formula(paste0("y ~ ", colnames(X)[j])), data = df))
aics <- sapply(cand, AIC)
data.frame(variable = colnames(X), AIC = aics)[order(aics), ][1:5, ]
res <- build_paths(dat, "y", preds, delta=2, eps=0.5, L=5, K=4, verbose=TRUE)
set.seed(1)
n <- 120; p <- 8
X <- matrix(rnorm(n*p), n, p)
colnames(X) <- paste0("x", 1:p)
beta <- c(2, -1.5, 0, 0, 1, rep(0, p-5))
y <- X %*% beta + rnorm(n)
dat <- data.frame(y=y, X)
preds <- colnames(dat)[-1]
res <- build_paths(dat, "y", preds, delta=2, eps=0.5, L=5, K=4, verbose=TRUE)
beta <- c(2, -1.5, 0, 0, 1, rep(0, p-5))
res <- build_paths(dat, "y", preds, delta=2, eps=0, L=5, K=4, verbose=TRUE)
# empty model AIC
parent_aic <- AIC(lm(y ~ 1, data = dat))
for (v in preds) {
child_aic <- AIC(lm(as.formula(paste("y ~", v)), data = dat))
improvement <- parent_aic - child_aic
cat(v, "AIC:", child_aic, "improvement:", improvement, "\n")
}
res <- build_paths(dat, "y", preds, delta = 2, eps = 0, L = 5, K = 4, verbose = TRUE)
build_paths <- function(
data,
response,
predictors,
delta = 2,
eps = 0.5,
L = 20,
K = length(predictors),
verbose = TRUE,
debug = TRUE  # NEW: print detailed step-by-step info
) {
stopifnot(response %in% colnames(data))
model_key <- function(vars) paste(sort(vars), collapse = "+")
model_aic <- function(vars) {
f <- as.formula(paste(response, "~", ifelse(length(vars)==0, "1", paste(vars, collapse="+"))))
AIC(lm(f, data = data))
}
aic_by_model <- list()
path_forest <- list()
# Step 0: empty model
empty <- character(0)
null_aic <- model_aic(empty)
aic_by_model[[model_key(empty)]] <- null_aic
path_forest[[1]] <- data.frame(
model = I(list(empty)),
AIC = null_aic
)
step <- 1
repeat {
if (step > K) break  # stop if step limit reached
parents <- lapply(path_forest[[step]]$model, unlist)
if (verbose) message("Step ", step, ": ", length(parents), " parent models")
children_all <- list()
child_keys <- character()
for (parent in parents) {
parent_k <- model_key(parent)
parent_aic <- aic_by_model[[parent_k]]
remaining <- setdiff(predictors, parent)
if (length(remaining) == 0) next
if (debug) {
cat("Parent model:", ifelse(length(parent)==0, "(empty)", paste(parent, collapse="+")),
"AIC =", parent_aic, "\n")
}
child_info <- lapply(remaining, function(v) {
vars <- c(parent, v)
key <- model_key(vars)
if (is.null(aic_by_model[[key]])) {
aic_by_model[[key]] <<- model_aic(vars)
}
list(vars = vars, key = key, AIC = aic_by_model[[key]])
})
child_AICs <- sapply(child_info, `[[`, "AIC")
best_child <- min(child_AICs)
# Keep children within delta of best and improvement >= eps
keep_idx <- which((child_AICs - best_child <= delta) &
(parent_aic - child_AICs >= eps))
if (debug) {
for (i in seq_along(child_info)) {
vars <- child_info[[i]]$vars
aic <- child_info[[i]]$AIC
improvement <- parent_aic - aic
keep <- ifelse(i %in% keep_idx, "KEEP", "REJECT")
cat("  Child:", paste(vars, collapse="+"), "AIC =", aic,
"improvement =", improvement, keep, "\n")
}
}
if (length(keep_idx) > 0) {
kept <- child_info[keep_idx]
children_all <- c(children_all, lapply(kept, `[[`, "vars"))
child_keys <- c(child_keys, sapply(kept, `[[`, "key"))
}
}
if (length(child_keys) == 0) {
if (verbose) message("No AIC-improving children. Stopping.")
break
}
# Deduplicate
unique_idx <- !duplicated(child_keys)
frontier <- children_all[unique_idx]
# Prune if > L
if (length(frontier) > L) {
AICs <- sapply(frontier, function(v) aic_by_model[[model_key(v)]])
frontier <- frontier[order(AICs)[1:L]]
}
# Store frontier as a data frame
df_frontier <- data.frame(
model = I(frontier),
AIC = sapply(frontier, function(v) aic_by_model[[model_key(v)]])
)
path_forest[[step + 1]] <- df_frontier
step <- step + 1
}
list(
path_forest = path_forest,
aic_by_model = aic_by_model,
meta = list(
response = response,
predictors = predictors,
delta = delta,
eps = eps,
L = L,
K = K
)
)
}
set.seed(1)
n <- 120; p <- 8
X <- matrix(rnorm(n*p), n, p)
colnames(X) <- paste0("x", 1:p)
beta <- c(2, -1.5, 0, 0, 1, rep(0, p-5))
y <- X %*% beta + rnorm(n)
dat <- data.frame(y=y, X)
preds <- colnames(dat)[-1]
res <- build_paths(dat, "y", preds, delta=2, eps=0.5, L=5, K=4, verbose=TRUE)
build_paths <- function(
data,
response,
predictors,
delta = 2,
eps = 0.5,
L = 20,
K = length(predictors),
verbose = TRUE,
debug = FALSE
) {
stopifnot(response %in% colnames(data))
model_key <- function(vars) paste(sort(vars), collapse = "+")
model_aic <- function(vars) {
f <- as.formula(paste(response, "~", ifelse(length(vars)==0, "1", paste(vars, collapse="+"))))
AIC(lm(f, data = data))
}
aic_by_model <- list()
path_forest <- list()
# Step 0: empty model
empty <- character(0)
null_aic <- model_aic(empty)
aic_by_model[[model_key(empty)]] <- null_aic
path_forest[[1]] <- data.frame(
model = I(list(empty)),
AIC = null_aic
)
step <- 1
repeat {
if (step > K) break  # stop if step limit reached
parents <- lapply(path_forest[[step]]$model, unlist)
if (verbose) message("Step ", step, ": ", length(parents), " parent models")
children_all <- list()
child_keys <- character()
for (parent in parents) {
parent_k <- model_key(parent)
parent_aic <- aic_by_model[[parent_k]]
remaining <- setdiff(predictors, parent)
if (length(remaining) == 0) next
if (debug) {
cat("Parent model:", ifelse(length(parent)==0, "(empty)", paste(parent, collapse="+")),
"AIC =", parent_aic, "\n")
}
child_info <- lapply(remaining, function(v) {
vars <- c(parent, v)
key <- model_key(vars)
if (is.null(aic_by_model[[key]])) {
aic_by_model[[key]] <<- model_aic(vars)
}
list(vars = vars, key = key, AIC = aic_by_model[[key]])
})
child_AICs <- sapply(child_info, `[[`, "AIC")
best_child <- min(child_AICs)
keep_idx <- which((child_AICs - best_child <= delta) &
(parent_aic - child_AICs >= eps))
if (debug) {
for (i in seq_along(child_info)) {
vars <- child_info[[i]]$vars
aic <- child_info[[i]]$AIC
improvement <- parent_aic - aic
keep <- ifelse(i %in% keep_idx, "KEEP", "REJECT")
cat("  Child:", paste(vars, collapse="+"), "AIC =", aic,
"improvement =", improvement, keep, "\n")
}
}
if (length(keep_idx) > 0) {
kept <- child_info[keep_idx]
children_all <- c(children_all, lapply(kept, `[[`, "vars"))
child_keys <- c(child_keys, sapply(kept, `[[`, "key"))
}
}
if (length(child_keys) == 0) {
if (verbose) message("No AIC-improving children. Stopping.")
break
}
# Deduplicate
unique_idx <- !duplicated(child_keys)
frontier <- children_all[unique_idx]
# Prune if > L
if (length(frontier) > L) {
AICs <- sapply(frontier, function(v) aic_by_model[[model_key(v)]])
frontier <- frontier[order(AICs)[1:L]]
}
# Store frontier as a data frame
df_frontier <- data.frame(
model = I(frontier),
AIC = sapply(frontier, function(v) aic_by_model[[model_key(v)]])
)
path_forest[[step + 1]] <- df_frontier
step <- step + 1
}
list(
path_forest = path_forest,
aic_by_model = aic_by_model,
meta = list(
response = response,
predictors = predictors,
delta = delta,
eps = eps,
L = L,
K = K
)
)
}
set.seed(1)
n <- 120; p <- 8
X <- matrix(rnorm(n*p), n, p)
colnames(X) <- paste0("x", 1:p)
beta <- c(2, -1.5, 0, 0, 1, rep(0, p-5))
y <- X %*% beta + rnorm(n)
dat <- data.frame(y=y, X)
preds <- colnames(dat)[-1]
res <- build_paths(dat, "y", preds, delta=2, eps=0.5, L=5, K=4, verbose=TRUE)
set.seed(1)
n <- 120; p <- 8
X <- matrix(rnorm(n*p), n, p)
colnames(X) <- paste0("x", 1:p)
beta <- c(2, -1.5, 0, 0, 1, rep(0, p-5))
y <- as.numeric(X %*% beta + rnorm(n))
dat <- data.frame(y=y, X)
preds <- colnames(dat)[-1]
parent_aic <- AIC(lm(y ~ 1, data=dat))
for (v in preds) {
aic <- AIC(lm(as.formula(paste("y ~", v)), data=dat))
cat(v, "parent AIC:", parent_aic, "child AIC:", aic, "improvement:", parent_aic - aic, "\n")
}
build_paths <- function(
data,
response,
predictors,
delta = 2,
eps = 0.5,
L = 20,
K = length(predictors),
verbose = TRUE,
debug = FALSE
) {
stopifnot(response %in% colnames(data))
model_key <- function(vars) paste(sort(vars), collapse = "+")
model_aic <- function(vars) {
f <- as.formula(paste(response, "~", ifelse(length(vars)==0, "1", paste(vars, collapse="+"))))
AIC(lm(f, data = data))
}
aic_by_model <- list()
path_forest <- list()
# Step 0: empty model
empty <- character(0)
null_aic <- model_aic(empty)
aic_by_model[[model_key(empty)]] <- null_aic
path_forest[[1]] <- data.frame(
model = I(list(empty)),
AIC = null_aic
)
step <- 1
repeat {
if (step > K) break  # stop if step limit reached
parents <- lapply(path_forest[[step]]$model, unlist)
if (verbose) message("Step ", step, ": ", length(parents), " parent models")
children_all <- list()
child_keys <- character()
for (parent in parents) {
parent_k <- model_key(parent)
parent_aic <- aic_by_model[[parent_k]]
remaining <- setdiff(predictors, parent)
if (length(remaining) == 0) next
if (debug) {
cat("Parent model:", ifelse(length(parent)==0, "(empty)", paste(parent, collapse="+")),
"AIC =", parent_aic, "\n")
}
child_info <- lapply(remaining, function(v) {
vars <- c(parent, v)
key <- model_key(vars)
if (is.null(aic_by_model[[key]])) {
aic_by_model[[key]] <<- model_aic(vars)
}
list(vars = vars, key = key, AIC = aic_by_model[[key]])
})
child_AICs <- sapply(child_info, `[[`, "AIC")
best_child <- min(child_AICs)
# Keep children within delta and improvement >= eps
keep_idx <- which((child_AICs - best_child <= delta) &
(parent_aic - child_AICs >= eps))
# FORCE keep the best child if none satisfy eps
if (length(keep_idx) == 0) {
keep_idx <- which.min(child_AICs)
}
if (debug) {
for (i in seq_along(child_info)) {
vars <- child_info[[i]]$vars
aic <- child_info[[i]]$AIC
improvement <- parent_aic - aic
keep <- ifelse(i %in% keep_idx, "KEEP", "REJECT")
cat("  Child:", paste(vars, collapse="+"), "AIC =", aic,
"improvement =", improvement, keep, "\n")
}
}
kept <- child_info[keep_idx]
children_all <- c(children_all, lapply(kept, `[[`, "vars"))
child_keys <- c(child_keys, sapply(kept, `[[`, "key"))
}
if (length(child_keys) == 0) {
if (verbose) message("No children left. Stopping.")
break
}
# Deduplicate
unique_idx <- !duplicated(child_keys)
frontier <- children_all[unique_idx]
# Prune if > L
if (length(frontier) > L) {
AICs <- sapply(frontier, function(v) aic_by_model[[model_key(v)]])
frontier <- frontier[order(AICs)[1:L]]
}
# Store frontier
df_frontier <- data.frame(
model = I(frontier),
AIC = sapply(frontier, function(v) aic_by_model[[model_key(v)]])
)
path_forest[[step + 1]] <- df_frontier
step <- step + 1
}
list(
path_forest = path_forest,
aic_by_model = aic_by_model,
meta = list(
response = response,
predictors = predictors,
delta = delta,
eps = eps,
L = L,
K = K
)
)
}
set.seed(1)
n <- 120; p <- 8
X <- matrix(rnorm(n*p), n, p)
colnames(X) <- paste0("x", 1:p)
beta <- c(2, -1.5, 0, 0, 1, rep(0, p-5))
y <- X %*% beta + rnorm(n)
dat <- data.frame(y=y, X)
preds <- colnames(dat)[-1]
res <- build_paths(dat, "y", preds, delta=2, eps=0.5, L=5, K=4, verbose=TRUE)
res
## 3.2  Stability estimation with resampling
stability <- function(
data,
response,
predictors,
B        = 50,
resample = c("bootstrap", "subsample"),
m        = NULL,
delta    = 2,
eps      = 0.5,
L        = 20,
K        = length(predictors),
verbose  = TRUE
) {
resample <- match.arg(resample)
n        <- nrow(data)
p        <- length(predictors)
# accumulator for sum_b z_j^(b)
pi_sum <- setNames(numeric(p), predictors)
for (b in seq_len(B)) {
## 1. draw resample indices
idx <- if (resample == "bootstrap") {
sample.int(n, n, replace = TRUE)
} else {
if (is.null(m)) m <- floor(0.8 * n)
sample.int(n, m, replace = FALSE)
}
data_b <- data[idx, , drop = FALSE]
## 2. run multi-path search
paths_b <- build_paths(
data       = data_b,
response   = response,
predictors = predictors,
delta      = delta,
eps        = eps,
L          = L,
K          = K,
verbose    = FALSE
)$path_forest
## 3. collect all models across steps, drop empty model
models_b <- unlist(lapply(paths_b, function(df) df$model), recursive = FALSE)
models_b <- Filter(function(m) length(m) > 0, models_b)
## 4. z_j^(b) = proportion of models containing predictor j
z_b <- numeric(p)
if (length(models_b) > 0) {
for (j in seq_along(predictors)) {
v <- predictors[j]
z_b[j] <- mean(vapply(models_b, function(m) v %in% m, logical(1)))
}
}
## accumulate
pi_sum <- pi_sum + z_b
if (verbose) message("Resample ", b, " of ", B)
}
## 5. stability vector Ï€_j = (1/B) * sum_b z_j^(b)
pi_sum / B
}
plausible_models <- function(path_forest, path_stability, delta=2, tau=0.6) {
AICdf <- data.frame(model=names(path_forest$aic_by_model), AIC=unlist(path_forest$aic_by_model), vars=I(strsplit(names(path_forest$aic_by_model), "\\+")))
kept_models_index <- c()
AICMin <- min(AICdf$AIC)
for (i in 1:length(AICdf$model)) {
if (AICdf$AIC[i] <= AICMin + delta) {
kept_models_index <- c(kept_models_index, i)
}
}
kept_models <- AICdf[kept_models_index,]
stability <- NA
kept_models <- data.frame(kept_models, stability)
remove.idx <- c()
for (m in 1:length(kept_models$model)) {
pidx <- which(path_forest$meta$predictors %in% kept_models$vars[[m]])
kept_models$stability[m] <- mean(path_stability[pidx])
if (kept_models$stability[m] < tau) {
remove.idx <- c(remove.idx, m * -1)
}
}
final_models <- kept_models[remove.idx,]
return(final_models)
}
set.seed(1)
n <- 120; p <- 8
X <- matrix(rnorm(n*p), n, p)
beta <- c(2, -1.5, 0, 0, 1, rep(0, p-5))
y <- X %*% beta + rnorm(n, sd = 1)
colnames(X) <- paste0("x", 1:p)
df <- as.data.frame(cbind(y, X))
# Fit a few single-step candidates to illustrate AIC comparisons:
aic_empty <- AIC(lm(y ~ 1, data = df))
cand <- lapply(1:p, function(j) lm(as.formula(paste0("y ~ ", colnames(X)[j])), data = df))
aics <- sapply(cand, AIC)
data.frame(variable = colnames(X), AIC = aics)[order(aics), ][1:5, ]
set.seed(2)
n <- 200; p <- 6
Xb <- matrix(rnorm(n*p), n, p)
linpred <- 1.2*Xb[,1] - 1*Xb[,2] + 0.8*Xb[,5]
prob <- 1 / (1 + exp(-linpred))
ybin <- rbinom(n, 1, prob)
colnames(Xb) <- paste0("x", 1:p)
dfb <- as.data.frame(cbind(y = ybin, Xb))
# Compare intercept-only vs. adding one variable by AIC:
fit0 <- glm(y ~ 1, family = binomial(), data = dfb)
aic0 <- AIC(fit0)
fits1 <- lapply(1:p, function(j) glm(as.formula(paste0("y ~ ", colnames(Xb)[j])),
family = binomial(), data = dfb))
aics1 <- sapply(fits1, AIC)
head(data.frame(variable = colnames(Xb), AIC = aics1)[order(aics1), ], 5)
forest <- build_paths(x = X, y = as.numeric(y), family = "gaussian", K = min(ncol(X), 10), eps = 1e-6, delta = 1, L = 50)
