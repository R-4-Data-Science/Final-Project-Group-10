---
title: "Program Function Examples"
author: "Soleil, Sam, Joe"
date: "2025-12-05"
output: html_document
---
This file provides examples for users to understand our code and how to implement it. 
##3.1: Multi-path forward selection
```{r}

```

##3.2: Resampling with model-set proportions
```{r}
stability <- function(
    data,
    response,
    predictors,
    B        = 50,
    resample = c("bootstrap", "subsample"),
    m        = NULL,                  
    delta    = 2,
    eps      = 0.5,
    L        = 20,
    K        = length(predictors),
    verbose  = TRUE
) {
  resample <- match.arg(resample)
  n        <- nrow(data)
  p        <- length(predictors)
  
  # accumulator for sum_b z_j^(b)
  pi_sum <- setNames(numeric(p), predictors)
  
  for (b in seq_len(B)) {
    
    ## draw resample indices
    idx <- if (resample == "bootstrap") {
      sample.int(n, n, replace = TRUE)
    } else {
      if (is.null(m)) m <- floor(0.8 * n)
      sample.int(n, m, replace = FALSE)
    }
    
    data_b <- data[idx, , drop = FALSE]
    
    ## run multi-path search 
    paths_b <- build_paths(
      data       = data_b,
      response   = response,
      predictors = predictors,
      delta      = delta,
      eps        = eps,
      L          = L,
      K          = K,
      verbose    = FALSE
    )$path_forest
    
    ## collect all models across steps, drop empty model
    models_b <- unlist(lapply(paths_b, function(df) df$model), recursive = FALSE)
    models_b <- Filter(function(m) length(m) > 0, models_b)
    
    ## z_j^(b) = proportion of models containing predictor j
    z_b <- numeric(p)
    if (length(models_b) > 0) {
      for (j in seq_along(predictors)) {
        v <- predictors[j]
        z_b[j] <- mean(vapply(models_b, function(m) v %in% m, logical(1)))
      }
    }
    
    ## accumulate
    pi_sum <- pi_sum + z_b
    if (verbose) message("Resample ", b, " of ", B)
  }
  
  ## stability vector Ï€_j = (1/B) * sum_b z_j^(b)
  pi_sum / B
}


```

##3.3: AIC Filter + average stability
```{r}

```


##5.1: Foward Path Selection
```{r}
#DATA
set.seed(1)
n <- 120; p <- 8
X <- matrix(rnorm(n*p), n, p)
beta <- c(2, -1.5, 0, 0, 1, rep(0, p-5))
y <- X %*% beta + rnorm(n, sd = 1)
colnames(X) <- paste0("x", 1:p)
df <- as.data.frame(cbind(y, X))

#SINGLE VARIABLE AICs#############-----------
# Empty model
aic_empty <- AIC(lm(y ~ 1, data = df))

# Candidate single-variable models
cand <- lapply(1:p, function(j) lm(as.formula(paste0("y ~ ", colnames(X)[j])), data = df))
aics <- sapply(cand, AIC)

# Top 5 lowest-AIC single-variable models
data.frame(variable = colnames(X), AIC = aics)[order(aics), ][1:5, ]

#Runnning Model ######-------

# Assume build_paths() is already defined
result <- build_paths(
  data = df,
  response = "y",
  predictors = colnames(X),
  delta = 2,   # keep children within 2 AIC of best
  eps = 0.1,   # must improve AIC at least 0.1
  L = 5,       # max models per step
  verbose = TRUE
)




```

Results 
```{r}
# Models at each step (frontiers)
result$path_forest

# AICs for all models visited
result$aic_by_model

```



##5.1: Forward Tree Algorithm not finished yet

#Linear Regression of Forward Tree Algorithm (Gaussian)
```{r}
# Data
data(mtcars)
X <- mtcars[, setdiff(names(mtcars), "mpg")]
y <- mtcars$mpg

# Run forward tree algorithm
result_gaussian <- algorithm_forward_tree(
  X = X,
  y = y,
  family = "gaussian",
  K = 3,   # max steps
  eps = 0.1,
  delta = 2,
  L = 5
)

# Inspect models by step
result_gaussian$models_by_step

```


#Logistic Regression of Forward Tree Algorithm (Gaussian)
```{r}
y_bin <- ifelse(mtcars$mpg > 20, 1, 0)
X <- mtcars[, setdiff(names(mtcars), "mpg")]

result_binomial <- algorithm_forward_tree(
  X = X,
  y = y_bin,
  family = "binomial",
  K = 3,
  eps = 0.1,
  delta = 2,
  L = 5
)

result_binomial$models_by_step

```

