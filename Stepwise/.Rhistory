forward_path_selection <- function(
data,
response,
predictors,
delta = 2,    # allowable AIC distance from parent’s best child
eps = 0.5,    # required AIC improvement over parent
L = 20,       # maximum number of models kept per step
verbose = TRUE
) {
# ---- helpers -------------------------------------------------------------
model_key <- function(vars) paste(sort(vars), collapse = "+")  # unique model key
model_aic <- function(vars) {                                 # fit model + compute AIC
f <- as.formula(
paste(response, "~",
ifelse(length(vars) == 0, "1", paste(vars, collapse = "+")))
)
AIC(lm(f, data = data))
}
# ---- storage -------------------------------------------------------------
aic_by_model <- list()
path_forest  <- list()
# Step 0: empty model
empty <- character(0)
path_forest[[1]] <- list(empty)
aic_by_model[[model_key(empty)]] <- model_aic(empty)
# ---- forward selection ---------------------------------------------------
step <- 1
repeat {
parents <- path_forest[[step]]
if (verbose) message("Step ", step, ": ", length(parents), " parents.")
children_all <- list()
child_keys <- character()
for (parent in parents) {
parent_k   <- model_key(parent)
parent_aic <- aic_by_model[[parent_k]]
remaining <- setdiff(predictors, parent)
if (length(remaining) == 0) next
# Generate all child models (add exactly one variable)
child_info <- lapply(remaining, function(v) {
vars <- c(parent, v)
key  <- model_key(vars)
if (is.null(aic_by_model[[key]])) {
aic_by_model[[key]] <<- model_aic(vars)
}
list(vars = vars, key = key, AIC = aic_by_model[[key]])
})
child_AICs <- sapply(child_info, `[[`, "AIC")
best_child <- min(child_AICs)
# keep children improving AIC enough and within delta
keep_idx <- which((child_AICs - best_child <= delta) &
(parent_aic - child_AICs >= eps))
if (length(keep_idx) > 0) {
kept <- child_info[keep_idx]
children_all <- c(children_all, lapply(kept, `[[`, "vars"))
child_keys   <- c(child_keys, sapply(kept, `[[`, "key"))
}
}
if (length(child_keys) == 0) {
if (verbose) message("No AIC-improving children. Stopping.")
break
}
# Remove duplicates
unique_idx <- !duplicated(child_keys)
frontier <- children_all[unique_idx]
# prune if needed
if (length(frontier) > L) {
if (verbose) message("Pruning from ", length(frontier), " → best ", L, " by AIC.")
AICs <- sapply(frontier, function(v) aic_by_model[[model_key(v)]])
frontier <- frontier[order(AICs)[1:L]]
}
path_forest[[step + 1]] <- frontier
step <- step + 1
}
# ---- output --------------------------------------------------------------
list(
path_forest  = path_forest,
aic_by_model = aic_by_model,
meta = list(
response   = response,
predictors = predictors,
delta = delta,
eps   = eps,
L     = L
)
)
}
stability <- function(
X, y,
B = 50L,
resample = c("bootstrap", "subsample"),
m = NULL,
build_paths_fun = build_paths,
...
) {
resample <- match.arg(resample)
X <- as.matrix(X)
n <- nrow(X)
p <- ncol(X)
if (length(y) != n) {
stop("Length of y (", length(y), ") must match nrow(X) (", n, ").")
}
if (resample == "subsample" && is.null(m)) {
m <- floor(sqrt(n))
}
colnames_X <- colnames(X)
if (is.null(colnames_X)) {
colnames_X <- paste0("x", seq_len(p))
}
z_mat <- matrix(NA_real_, nrow = B, ncol = p)
colnames(z_mat) <- colnames_X
for (b in seq_len(B)) {
# --- draw indices for this resample ---
idx <- if (resample == "bootstrap") {
sample.int(n, n, replace = TRUE)
} else {
sample.int(n, m, replace = FALSE)
}
X_b <- X[idx, , drop = FALSE]
y_b <- y[idx]
# --- run multi-path search on this resample ---
forest <- build_paths_fun(X_b, y_b, ...)
#each model = vector of indices
models <- models_from_forest(forest)
if (length(models) == 0L) {
# no models: everything is zero for this resample
z_mat[b, ] <- 0
} else {
M <- model_indicator_matrix(models, p = p)
# proportion of models containing each predictor j on resample b
z_mat[b, ] <- colMeans(M)
}
}
pi <- colMeans(z_mat)
out <- list(
pi   = pi,
z    = z_mat,
meta = list(
B        = B,
resample = resample,
m        = if (resample == "subsample") m else n,
p        = p,
colnames = colnames_X,
build_paths_fun = deparse(substitute(build_paths_fun)),
build_paths_args = list(...)
)
)
class(out) <- c("path_stability", class(out))
out
}
#' )
#'
#' # View frontier models at each step
#' result$path_forest
#'
#' # View AICs for all evaluated models
#' result$aic_by_model
#' }
#'
#' @export
build_paths <- function(
data,
response,
predictors,
delta = 2,    # allowable AIC distance from parent’s best child
eps = 0.5,    # required AIC improvement over parent
L = 20,       # maximum number of models kept per step
verbose = TRUE
) {
# ---- helpers -------------------------------------------------------------
model_key <- function(vars) paste(sort(vars), collapse = "+")  # unique model key
model_aic <- function(vars) {                                 # fit model + compute AIC
f <- as.formula(
paste(response, "~",
ifelse(length(vars) == 0, "1", paste(vars, collapse = "+")))
)
AIC(lm(f, data = data))
}
# ---- storage -------------------------------------------------------------
aic_by_model <- list()
path_forest  <- list()
# Step 0: empty model
empty <- character(0)
path_forest[[1]] <- list(empty)
aic_by_model[[model_key(empty)]] <- model_aic(empty)
# ---- forward selection ---------------------------------------------------
step <- 1
repeat {
parents <- path_forest[[step]]
if (verbose) message("Step ", step, ": ", length(parents), " parents.")
children_all <- list()
child_keys <- character()
for (parent in parents) {
parent_k   <- model_key(parent)
parent_aic <- aic_by_model[[parent_k]]
remaining <- setdiff(predictors, parent)
if (length(remaining) == 0) next
# Generate all child models (add exactly one variable)
child_info <- lapply(remaining, function(v) {
vars <- c(parent, v)
key  <- model_key(vars)
if (is.null(aic_by_model[[key]])) {
aic_by_model[[key]] <<- model_aic(vars)
}
list(vars = vars, key = key, AIC = aic_by_model[[key]])
})
child_AICs <- sapply(child_info, `[[`, "AIC")
best_child <- min(child_AICs)
# keep children improving AIC enough and within delta
keep_idx <- which((child_AICs - best_child <= delta) &
(parent_aic - child_AICs >= eps))
if (length(keep_idx) > 0) {
kept <- child_info[keep_idx]
children_all <- c(children_all, lapply(kept, `[[`, "vars"))
child_keys   <- c(child_keys, sapply(kept, `[[`, "key"))
}
}
if (length(child_keys) == 0) {
if (verbose) message("No AIC-improving children. Stopping.")
break
}
# Remove duplicates
unique_idx <- !duplicated(child_keys)
frontier <- children_all[unique_idx]
# prune if needed
if (length(frontier) > L) {
if (verbose) message("Pruning from ", length(frontier), " → best ", L, " by AIC.")
AICs <- sapply(frontier, function(v) aic_by_model[[model_key(v)]])
frontier <- frontier[order(AICs)[1:L]]
}
path_forest[[step + 1]] <- frontier
step <- step + 1
}
# ---- output --------------------------------------------------------------
list(
path_forest  = path_forest,
aic_by_model = aic_by_model,
meta = list(
response   = response,
predictors = predictors,
delta = delta,
eps   = eps,
L     = L
)
)
}
# Example data
data(mtcars)
# Define response + predictors
response <- "mpg"
predictors <- setdiff(colnames(mtcars), response)
# Run forward path selection
result <- forward_path_selection(
data = mtcars,
response = response,
predictors = predictors,
delta = 2,
eps = 0.1,
L = 10,
verbose = TRUE
)
# List of frontiers by step
result$path_forest
# AIC by model key
result$aic_by_model
# Meta info
result$meta
devtools::load_all(".")
install.packages(c("devtools", "roxygen2"))
library(devtools)
library(roxygen2)
install.packages(c("devtools", "roxygen2"))
# Generate documentation from roxygen2 comments
document()
build()
devtools::load_all(".")
devtools::load_all(".")
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
build()
install()
set.seed(1)
n <- 120; p <- 8
X <- matrix(rnorm(n*p), n, p)
beta <- c(2, -1.5, 0, 0, 1, rep(0, p-5))
y <- X %*% beta + rnorm(n, sd = 1)
colnames(X) <- paste0("x", 1:p)
df <- as.data.frame(cbind(y, X))
# Fit a few single-step candidates to illustrate AIC comparisons:
aic_empty <- AIC(lm(y ~ 1, data = df))
cand <- lapply(1:p, function(j) lm(as.formula(paste0("y ~ ", colnames(X)[j])), data = df))
aics <- sapply(cand, AIC)
data.frame(variable = colnames(X), AIC = aics)[order(aics), ][1:5, ]
set.seed(2)
n <- 200; p <- 6
Xb <- matrix(rnorm(n*p), n, p)
linpred <- 1.2*Xb[,1] - 1*Xb[,2] + 0.8*Xb[,5]
prob <- 1 / (1 + exp(-linpred))
ybin <- rbinom(n, 1, prob)
colnames(Xb) <- paste0("x", 1:p)
dfb <- as.data.frame(cbind(y = ybin, Xb))
# Compare intercept-only vs. adding one variable by AIC:
fit0 <- glm(y ~ 1, family = binomial(), data = dfb)
aic0 <- AIC(fit0)
fits1 <- lapply(1:p, function(j) glm(as.formula(paste0("y ~ ", colnames(Xb)[j])),
family = binomial(), data = dfb))
aics1 <- sapply(fits1, AIC)
head(data.frame(variable = colnames(Xb), AIC = aics1)[order(aics1), ], 5)
# install.packages("stepwise")
remotes::install_github("R-4-Data-Science/Final-Project-Group-10")
set.seed(1)
n <- 120; p <- 8
X <- matrix(rnorm(n*p), n, p)
beta <- c(2, -1.5, 0, 0, 1, rep(0, p-5))
y <- X %*% beta + rnorm(n, sd = 1)
colnames(X) <- paste0("x", 1:p)
df <- as.data.frame(cbind(y, X))
# Fit a few single-step candidates to illustrate AIC comparisons:
aic_empty <- AIC(lm(y ~ 1, data = df))
cand <- lapply(1:p, function(j) lm(as.formula(paste0("y ~ ", colnames(X)[j])), data = df))
aics <- sapply(cand, AIC)
data.frame(variable = colnames(X), AIC = aics)[order(aics), ][1:5, ]
set.seed(2)
n <- 200; p <- 6
Xb <- matrix(rnorm(n*p), n, p)
linpred <- 1.2*Xb[,1] - 1*Xb[,2] + 0.8*Xb[,5]
prob <- 1 / (1 + exp(-linpred))
ybin <- rbinom(n, 1, prob)
colnames(Xb) <- paste0("x", 1:p)
dfb <- as.data.frame(cbind(y = ybin, Xb))
# Compare intercept-only vs. adding one variable by AIC:
fit0 <- glm(y ~ 1, family = binomial(), data = dfb)
aic0 <- AIC(fit0)
fits1 <- lapply(1:p, function(j) glm(as.formula(paste0("y ~ ", colnames(Xb)[j])),
family = binomial(), data = dfb))
aics1 <- sapply(fits1, AIC)
head(data.frame(variable = colnames(Xb), AIC = aics1)[order(aics1), ], 5)
# install.packages("stepwise")
remotes::install_github("R-4-Data-Science/Final-Project-Group-10")
# install.packages("stepwise")
remotes::install_github("R-4-Data-Science/Final-Project-Group-10")
library(<stepwise>)
library(stepwise)
